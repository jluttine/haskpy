
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Maybe &#8212; HaskPy 0.1.dev1+geded28e documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="haskpy.types.maybe.Nothing" href="haskpy.types.maybe.Nothing.html" />
    <link rel="prev" title="haskpy.types.maybe" href="haskpy.types.maybe.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <dl class="py data">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">haskpy.types.maybe.</span></span><span class="sig-name descname"><span class="pre">Maybe</span></span></dt>
<dd></dd></dl>

<section id="maybe">
<h1>Maybe<a class="headerlink" href="#maybe" title="Permalink to this heading">¶</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Maybe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/haskpy/types/maybe.html#Maybe"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#haskpy.types.maybe.Maybe" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="haskpy.typeclasses.monad.Monad.html#haskpy.typeclasses.monad.Monad" title="haskpy.typeclasses.monad.Monad"><code class="xref py py-class docutils literal notranslate"><span class="pre">Monad</span></code></a>, <a class="reference internal" href="haskpy.typeclasses.semigroup.Commutative.html#haskpy.typeclasses.semigroup.Commutative" title="haskpy.typeclasses.semigroup.Commutative"><code class="xref py py-class docutils literal notranslate"><span class="pre">Commutative</span></code></a>, <a class="reference internal" href="haskpy.typeclasses.monoid.Monoid.html#haskpy.typeclasses.monoid.Monoid" title="haskpy.typeclasses.monoid.Monoid"><code class="xref py py-class docutils literal notranslate"><span class="pre">Monoid</span></code></a>, <a class="reference internal" href="haskpy.typeclasses.hashable.Hashable.html#haskpy.typeclasses.hashable.Hashable" title="haskpy.typeclasses.hashable.Hashable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Hashable</span></code></a>, <a class="reference internal" href="haskpy.typeclasses.traversable.Traversable.html#haskpy.typeclasses.traversable.Traversable" title="haskpy.typeclasses.traversable.Traversable"><code class="xref py py-class docutils literal notranslate"><span class="pre">Traversable</span></code></a></p>
<p>Type <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span></code> for a value that might be present or not</p>
<p><a class="reference internal" href="#haskpy.types.maybe.Maybe" title="haskpy.types.maybe.Maybe"><code class="xref py py-class docutils literal notranslate"><span class="pre">Maybe</span></code></a> monad is one of the simplest yet very useful monads. It
represents a case when you might have a value or not. If you have a value,
it’s wrapped with <a class="reference internal" href="haskpy.types.maybe.Just.html#haskpy.types.maybe.Just" title="haskpy.types.maybe.Just"><code class="xref py py-func docutils literal notranslate"><span class="pre">Just()</span></code></a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">Just</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">Just(42)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">Maybe</span>
</pre></div>
</div>
<p>If you don’t have a value, it’s represented with <a class="reference internal" href="haskpy.types.maybe.Nothing.html#haskpy.types.maybe.Nothing" title="haskpy.types.maybe.Nothing"><code class="xref py py-data docutils literal notranslate"><span class="pre">Nothing</span></code></a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">Nothing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">Nothing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">Maybe</span>
</pre></div>
</div>
<p>Quite often Python programmers handle this case by using <code class="docutils literal notranslate"><span class="pre">None</span></code> to
represent “no value” and then just the plain value otherwise. However,
whenever you want to do something with the value, you need to first check
if it’s <code class="docutils literal notranslate"><span class="pre">None</span></code> or not, and handle both cases somehow. And, more
importantly, you need to remember to do this every time you use a value
that might be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>With HaskPy, it is explicit that the value might exist or not, so you are
forced to handle both cases. Or, more interestingly, you can just focus on
the value and let HaskPy take care of the special case. Let’s see what this
means. Say you have a function that you’d like to apply to the value:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>You can use <a class="reference internal" href="haskpy.typeclasses.functor.Functor.html#haskpy.typeclasses.functor.Functor.map" title="haskpy.typeclasses.functor.Functor.map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Functor.map()</span></code></a> method to apply it to the value:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">Just(43)</span>
</pre></div>
</div>
<p>Or, equivalently, use a function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hp</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">Just(43)</span>
</pre></div>
</div>
<p>Quite often there are corresponding functions for the methods and it may
depend on the context which one is more convenient to use. The order of the
arguments might be slightly different in the function than in the method
though.</p>
<p>But what would’ve happened if we had <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> instead?</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hp</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">Nothing</span>
</pre></div>
</div>
<p>So, nothing was done to <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>. But the important thing is that you
didn’t need to worry about whether <code class="docutils literal notranslate"><span class="pre">x</span></code> or <code class="docutils literal notranslate"><span class="pre">y</span></code> was <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> or
contained a real value, <a class="reference internal" href="#haskpy.types.maybe.Maybe" title="haskpy.types.maybe.Maybe"><code class="xref py py-class docutils literal notranslate"><span class="pre">Maybe</span></code></a> took care of that under the hood.
If in some cases you need to handle both cases explicitly, you can use
<a class="reference internal" href="haskpy.utils.match.html#haskpy.utils.match" title="haskpy.utils.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a> function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">Just</span><span class="o">=</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">Nothing</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">666</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">84</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">666</span>
</pre></div>
</div>
<p>With <a class="reference internal" href="haskpy.utils.match.html#haskpy.utils.match" title="haskpy.utils.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a> you need to explicitly handle all possible cases or
you will get an error even if your variable wasn’t <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>. Therefore,
you’ll never forget to take into account <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> case as might happen
with the classic <code class="docutils literal notranslate"><span class="pre">None</span></code> approach.</p>
<p>Alright, this was just a very tiny starter about <a class="reference internal" href="#haskpy.types.maybe.Maybe" title="haskpy.types.maybe.Maybe"><code class="xref py py-class docutils literal notranslate"><span class="pre">Maybe</span></code></a>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="haskpy.types.either.Either.html#haskpy.types.either.Either" title="haskpy.types.either.Either"><code class="xref py py-obj docutils literal notranslate"><span class="pre">haskpy.types.either.Either</span></code></a></dt><dd></dd>
</dl>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.__add__">
<span class="sig-name descname"><span class="pre">__add__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#haskpy.types.maybe.Maybe.__add__" title="Permalink to this definition">¶</a></dt>
<dd><p>Append two monoids</p>
<p>Using <code class="docutils literal notranslate"><span class="pre">+</span></code> operator to append two monoid values seems natural because
that’s what Python is doing by default because lists are concatenated
with <code class="docutils literal notranslate"><span class="pre">+</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.__annotations__">
<span class="sig-name descname"><span class="pre">__annotations__</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">{}</span></em><a class="headerlink" href="#haskpy.types.maybe.Maybe.__annotations__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.__contains__">
<span class="sig-name descname"><span class="pre">__contains__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#haskpy.types.maybe.Maybe.__contains__" title="Permalink to this definition">¶</a></dt>
<dd><p>Override elem if you want to change the default implementation</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.__eq__">
<span class="sig-name descname"><span class="pre">__eq__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/haskpy/types/maybe.html#Maybe.__eq__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#haskpy.types.maybe.Maybe.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark method non-existing</p>
<p>This is a workaround for Python forcefully creating some methods. One
cannot create objects that don’t have <code class="docutils literal notranslate"><span class="pre">__eq__</span></code>, <code class="docutils literal notranslate"><span class="pre">__ge__</span></code>, <code class="docutils literal notranslate"><span class="pre">__gt__</span></code>
and many other methods. They are there and it’s not possible to delete
them. With this wrapper you can override those methods so that they won’t
show up in <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> listing and if accessed in any way,
<code class="docutils literal notranslate"><span class="pre">AttributeError</span></code> is raised. Note that it just hides the methods, one can
still access them as <code class="docutils literal notranslate"><span class="pre">object.__getattribute__(obj,</span> <span class="pre">&quot;__eq__&quot;)</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.__eq_test__">
<span class="sig-name descname"><span class="pre">__eq_test__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/haskpy/types/maybe.html#Maybe.__eq_test__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#haskpy.types.maybe.Maybe.__eq_test__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/haskpy/types/maybe.html#Maybe.__hash__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#haskpy.types.maybe.Maybe.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark method non-existing</p>
<p>This is a workaround for Python forcefully creating some methods. One
cannot create objects that don’t have <code class="docutils literal notranslate"><span class="pre">__eq__</span></code>, <code class="docutils literal notranslate"><span class="pre">__ge__</span></code>, <code class="docutils literal notranslate"><span class="pre">__gt__</span></code>
and many other methods. They are there and it’s not possible to delete
them. With this wrapper you can override those methods so that they won’t
show up in <code class="docutils literal notranslate"><span class="pre">__dir__</span></code> listing and if accessed in any way,
<code class="docutils literal notranslate"><span class="pre">AttributeError</span></code> is raised. Note that it just hides the methods, one can
still access them as <code class="docutils literal notranslate"><span class="pre">object.__getattribute__(obj,</span> <span class="pre">&quot;__eq__&quot;)</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.__iter__">
<span class="sig-name descname"><span class="pre">__iter__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#haskpy.types.maybe.Maybe.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Override to_iter if you want to change the default implementation</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.__len__">
<span class="sig-name descname"><span class="pre">__len__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#haskpy.types.maybe.Maybe.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Override length if you want to change the default implementation</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.__lshift__">
<span class="sig-name descname"><span class="pre">__lshift__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#haskpy.types.maybe.Maybe.__lshift__" title="Permalink to this definition">¶</a></dt>
<dd><p>Sequence with <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> similarly as with <code class="docutils literal notranslate"><span class="pre">&lt;*</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> in Haskell</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.__matmul__">
<span class="sig-name descname"><span class="pre">__matmul__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#haskpy.types.maybe.Maybe.__matmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Application operand <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> applies similarly as <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> in Haskell</p>
<p><code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">&#64;</span> <span class="pre">x</span></code> translates to <code class="docutils literal notranslate"><span class="pre">f.apply_to(x)</span></code>, <code class="docutils literal notranslate"><span class="pre">x.apply(f)</span></code> and
<code class="docutils literal notranslate"><span class="pre">apply(f,</span> <span class="pre">x)</span></code>.</p>
<p>Why <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> operator?</p>
<ul class="simple">
<li><p>It’s not typically used as often as some other more common operators
so less risk for confusion.</p></li>
<li><p>The operator is not a commutative as isn’t <code class="docutils literal notranslate"><span class="pre">apply</span></code> either.</p></li>
<li><p>If we see matrix as some structure, then matrix multiplication takes
both left and right operand inside this structure and gives a result
also inside this structure, similarly as <code class="docutils literal notranslate"><span class="pre">apply</span></code> does. So it’s an
operator for two operands having a similar structure.</p></li>
<li><p>The operator evaluates the contained function(s) at the contained
value(s). Thus, <code class="docutils literal notranslate"><span class="pre">f</span></code> “at” <code class="docutils literal notranslate"><span class="pre">x</span></code> makes perfect sense.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.__mod__">
<span class="sig-name descname"><span class="pre">__mod__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#haskpy.types.maybe.Maybe.__mod__" title="Permalink to this definition">¶</a></dt>
<dd><p>Use <code class="docutils literal notranslate"><span class="pre">%</span></code> as bind operator similarly as <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> in Haskell</p>
<p>That is, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">%</span> <span class="pre">f</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">bind(x,</span> <span class="pre">f)</span></code> and <code class="docutils literal notranslate"><span class="pre">x.bind(f)</span></code>.</p>
<p>Why <code class="docutils literal notranslate"><span class="pre">%</span></code> operator?</p>
<ul class="simple">
<li><p>It’s not very often used so less risk for confusion.</p></li>
<li><p>It’s not commutative as isn’t bind either.</p></li>
<li><p>It is similar to bind in a sense that the result has the same unit as
the left operand while the right operand has different unit.</p></li>
<li><p>The symbol works visually as a line “binds” two circles and on the
other hand two circles tell about two similar structures on both
sides but those structures are just on different “level”.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.__ne__">
<span class="sig-name descname"><span class="pre">__ne__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#haskpy.types.maybe.Maybe.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>Inequality comparison: <code class="docutils literal notranslate"><span class="pre">Eq</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></code></p>
<p>Can be used as <code class="docutils literal notranslate"><span class="pre">!=</span></code> operator.</p>
<p>The default implementation uses <code class="docutils literal notranslate"><span class="pre">__eq__</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.__rpow__">
<span class="sig-name descname"><span class="pre">__rpow__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#haskpy.types.maybe.Maybe.__rpow__" title="Permalink to this definition">¶</a></dt>
<dd><p>Lifting operator <code class="docutils literal notranslate"><span class="pre">**</span></code> lifts similarly as <code class="docutils literal notranslate"><span class="pre">&lt;$&gt;</span></code> in Haskell</p>
<p><code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">**</span> <span class="pre">x</span></code> translates to <code class="docutils literal notranslate"><span class="pre">x.map(f)</span></code> and <code class="docutils literal notranslate"><span class="pre">map(f,</span> <span class="pre">x)</span></code>.</p>
<p>Why <code class="docutils literal notranslate"><span class="pre">**</span></code> operator?</p>
<ul class="simple">
<li><p>It’s not typically used as often as multiplication or addition so
less risk of confusion.</p></li>
<li><p>It’s not commutative operator as isn’t lifting either.</p></li>
<li><p>The two operands have very different roles. They are not at the same
“level”.</p></li>
<li><p>The right operand is “higher”, that is, it’s inside a structure and
the left operand is kind of “raised to the power” of the second
operand, where the “power” is the functorial structure.</p></li>
<li><p>The same operand is also used for function composition because
function composition is just mapping. Visually the symbol can be
seen as chaining two stars similarly as function composition chains
two functions.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.__rshift__">
<span class="sig-name descname"><span class="pre">__rshift__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#haskpy.types.maybe.Maybe.__rshift__" title="Permalink to this definition">¶</a></dt>
<dd><p>Sequence with <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> similarly as with <code class="docutils literal notranslate"><span class="pre">*&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> in Haskell</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.append">
<span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/haskpy/types/maybe.html#Maybe.append"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#haskpy.types.maybe.Maybe.append" title="Permalink to this definition">¶</a></dt>
<dd><p>m -&gt; m -&gt; m</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#haskpy.types.maybe.Maybe.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>m a -&gt; m (a -&gt; b) -&gt; m b</p>
<blockquote>
<div><p>self :: m a</p>
<p>f :: m (a -&gt; b)</p>
</div></blockquote>
<p>Default implementation is based on <code class="docutils literal notranslate"><span class="pre">bind</span></code> and <code class="docutils literal notranslate"><span class="pre">map</span></code>. In order to
use <code class="docutils literal notranslate"><span class="pre">bind</span></code>, let’s write its type as follows:</p>
<blockquote>
<div><p>bind :: m (a -&gt; b) -&gt; ((a -&gt; b) -&gt; m b) -&gt; m b</p>
</div></blockquote>
<p>Let’s also use a simple helper function:</p>
<blockquote>
<div><p>h = g -&gt; map g self :: (a -&gt; b) -&gt; m b</p>
</div></blockquote>
<p>Now:</p>
<blockquote>
<div><p>bind f h :: m b</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.apply_first">
<span class="sig-name descname"><span class="pre">apply_first</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#haskpy.types.maybe.Maybe.apply_first" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine two actions, keeping only the result of the first</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Apply</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.apply_second">
<span class="sig-name descname"><span class="pre">apply_second</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#haskpy.types.maybe.Maybe.apply_second" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine two actions, keeping only the result of the second</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Apply</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.apply_to">
<span class="sig-name descname"><span class="pre">apply_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/haskpy/types/maybe.html#Maybe.apply_to"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#haskpy.types.maybe.Maybe.apply_to" title="Permalink to this definition">¶</a></dt>
<dd><p>f (a -&gt; b) -&gt; f a -&gt; f b</p>
<p>Default implementation is based on <code class="docutils literal notranslate"><span class="pre">apply</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.bind">
<span class="sig-name descname"><span class="pre">bind</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/haskpy/types/maybe.html#Maybe.bind"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#haskpy.types.maybe.Maybe.bind" title="Permalink to this definition">¶</a></dt>
<dd><p>m a -&gt; (a -&gt; m b) -&gt; m b</p>
<p>Default implementation is based on <code class="docutils literal notranslate"><span class="pre">join</span></code> and <code class="docutils literal notranslate"><span class="pre">map</span></code>:</p>
<p>self :: m a</p>
<p>f :: a -&gt; m b</p>
<p>map f :: m a -&gt; m (m b)</p>
<p>join :: m (m b) -&gt; m b</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.elem">
<span class="sig-name descname"><span class="pre">elem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#haskpy.types.maybe.Maybe.elem" title="Permalink to this definition">¶</a></dt>
<dd><p>t a -&gt; a -&gt; bool</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.empty">
<span class="sig-name descname"><span class="pre">empty</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">Nothing</span></em><a class="reference internal" href="../_modules/haskpy/types/maybe.html#Maybe.empty"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#haskpy.types.maybe.Maybe.empty" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.flap">
<span class="sig-name descname"><span class="pre">flap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#haskpy.types.maybe.Maybe.flap" title="Permalink to this definition">¶</a></dt>
<dd><p>Functor f =&gt; f (a -&gt; b) -&gt; a - &gt; f b</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.fold">
<span class="sig-name descname"><span class="pre">fold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">monoid</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#haskpy.types.maybe.Maybe.fold" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.fold2">
<span class="sig-name descname"><span class="pre">fold2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">monoid</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#haskpy.types.maybe.Maybe.fold2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.fold_map">
<span class="sig-name descname"><span class="pre">fold_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">monoid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/haskpy/types/maybe.html#Maybe.fold_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#haskpy.types.maybe.Maybe.fold_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Monoid m =&gt; t a -&gt; (a -&gt; m) -&gt; m (ignoring <code class="docutils literal notranslate"><span class="pre">monoid</span></code> argument)</p>
<p>The default implementation is based on <code class="docutils literal notranslate"><span class="pre">foldl</span></code> (or, if not
implemented, recursively on <code class="docutils literal notranslate"><span class="pre">foldr</span></code>). Thus, all possibilities for
parallelism is lost.</p>
<p><code class="docutils literal notranslate"><span class="pre">monoid</span></code> is the monoidic class of the values inside the foldable. It
is only used to determine the identity value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.foldl">
<span class="sig-name descname"><span class="pre">foldl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">combine</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/haskpy/types/maybe.html#Maybe.foldl"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#haskpy.types.maybe.Maybe.foldl" title="Permalink to this definition">¶</a></dt>
<dd><p>t a -&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; b</p>
<p>The default implementation is based on <code class="docutils literal notranslate"><span class="pre">foldr</span></code> (or, if not
implemented, recursively on <code class="docutils literal notranslate"><span class="pre">fold_map</span></code>). Either way, the default
implementation doesn’t scale up well, so an instance implementation is
strongly recommended.</p>
<p>Intuition:</p>
<ul class="simple">
<li><p>equivalent to for-loop on lists</p></li>
<li><p>never works on infinite lists (so not possible to implement <code class="docutils literal notranslate"><span class="pre">map</span></code>
in terms of <code class="docutils literal notranslate"><span class="pre">foldl</span></code>)</p></li>
</ul>
<p class="rubric">References</p>
<p><a class="reference external" href="https://www.youtube.com/watch?v=GPwtT31zKRY">Tony Morris - An Intuition for List Folds</a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.foldr">
<span class="sig-name descname"><span class="pre">foldr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">combine</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/haskpy/types/maybe.html#Maybe.foldr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#haskpy.types.maybe.Maybe.foldr" title="Permalink to this definition">¶</a></dt>
<dd><p>t a -&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; b</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The default is very poor in Python. It is strongly recommended to
provide an instance implementation for this.</p>
</div>
<p>The default implementation uses <code class="docutils literal notranslate"><span class="pre">fold_map</span></code> by utilizing
(endo)function monoid:</p>
<blockquote>
<div><p>empty :: b -&gt; b</p>
<p>append :: (b -&gt; b) -&gt; (b -&gt; b) -&gt; (b -&gt; b)</p>
</div></blockquote>
<p>One can see <code class="docutils literal notranslate"><span class="pre">combine</span></code> function as a transformation to this monoid:</p>
<blockquote>
<div><p>combine :: a -&gt; (b -&gt; b)</p>
</div></blockquote>
<p>Then, just use endofunction monoid to compose all those <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code>
endofunctions into a single endofunction <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code>. Finally, apply
this function to the initial value.</p>
<p>Intuition:</p>
<ul class="simple">
<li><p>performs constructor replacement</p></li>
<li><p>may work on infinite lists</p></li>
<li><p>doesn’t “calculate from the right” but associates to the right
(otherwise it couldn’t work on infinite lists)</p></li>
</ul>
<p class="rubric">References</p>
<p><a class="reference external" href="https://www.youtube.com/watch?v=GPwtT31zKRY">Tony Morris - An Intuition for List Folds</a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.head">
<span class="sig-name descname"><span class="pre">head</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">default</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#haskpy.types.maybe.Maybe.head" title="Permalink to this definition">¶</a></dt>
<dd><p>Return head (or default if no head): <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.join">
<span class="sig-name descname"><span class="pre">join</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#haskpy.types.maybe.Maybe.join" title="Permalink to this definition">¶</a></dt>
<dd><p>m (m a) -&gt; m a</p>
<p>Default implementation is based on <code class="docutils literal notranslate"><span class="pre">bind</span></code>:</p>
<p>self :: m (m a)</p>
<p>identity :: m a -&gt; m a</p>
<p>bind :: m (m a) -&gt; (m a -&gt; m a) -&gt; m a</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.length">
<span class="sig-name descname"><span class="pre">length</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/haskpy/types/maybe.html#Maybe.length"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#haskpy.types.maybe.Maybe.length" title="Permalink to this definition">¶</a></dt>
<dd><p>t a -&gt; int</p>
<p>The default implementation isn’t very efficient as it traverses through
the iterator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.map">
<span class="sig-name descname"><span class="pre">map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/haskpy/types/maybe.html#Maybe.map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#haskpy.types.maybe.Maybe.map" title="Permalink to this definition">¶</a></dt>
<dd><p>m a -&gt; (a -&gt; b) -&gt; m b</p>
<p>Default implementation is based on <code class="docutils literal notranslate"><span class="pre">bind</span></code> and <code class="docutils literal notranslate"><span class="pre">pure</span></code>. This
implementation needs to be provided because the default implementation
of <code class="docutils literal notranslate"><span class="pre">apply</span></code> uses <code class="docutils literal notranslate"><span class="pre">map</span></code> thus creating a circular dependency between
the default <code class="docutils literal notranslate"><span class="pre">map</span></code> defined in <code class="docutils literal notranslate"><span class="pre">Applicative</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.null">
<span class="sig-name descname"><span class="pre">null</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#haskpy.types.maybe.Maybe.null" title="Permalink to this definition">¶</a></dt>
<dd><p>t a -&gt; bool</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.pure">
<span class="sig-name descname"><span class="pre">pure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/haskpy/types/maybe.html#Maybe.pure"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#haskpy.types.maybe.Maybe.pure" title="Permalink to this definition">¶</a></dt>
<dd><p>a -&gt; m a</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.replace">
<span class="sig-name descname"><span class="pre">replace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#haskpy.types.maybe.Maybe.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Haskell ($&gt;) operator</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.sequence">
<span class="sig-name descname"><span class="pre">sequence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">applicative</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/haskpy/types/maybe.html#Maybe.sequence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#haskpy.types.maybe.Maybe.sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Evalute each action in the structure and collect the results</p>
<p>For <code class="docutils literal notranslate"><span class="pre">Traversable</span> <span class="pre">t</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Applicative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">t</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">t</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>The default implementation is based on <code class="docutils literal notranslate"><span class="pre">traverse</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.sum">
<span class="sig-name descname"><span class="pre">sum</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#haskpy.types.maybe.Maybe.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>t a -&gt; number</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.to_iter">
<span class="sig-name descname"><span class="pre">to_iter</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/haskpy/types/maybe.html#Maybe.to_iter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#haskpy.types.maybe.Maybe.to_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>t a -&gt; Iter a</p>
<p>Instead of to_list (as in Haskell), let’s provide to_iter. With
iterables, we can write efficient implementations for many other
methods (e.g., sum, elem) even for large or sometimes infinite
foldables.</p>
<p>The default implementation isn’t very efficient as it uses folding to
construct the iterator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="haskpy.types.maybe.Maybe.traverse">
<span class="sig-name descname"><span class="pre">traverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">applicative</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#haskpy.types.maybe.Maybe.traverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Map each element to an action and collect the results</p>
<p>For <code class="docutils literal notranslate"><span class="pre">Traversable</span> <span class="pre">t</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Applicative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">t</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>The default implementation is based on <code class="docutils literal notranslate"><span class="pre">sequence</span></code>.</p>
</dd></dl>

</dd></dl>

</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">HaskPy</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Table of contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../motivation.html">Motivation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview.html">Overview</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../api.html">API</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="haskpy.types.html">haskpy.types</a></li>
<li class="toctree-l2"><a class="reference internal" href="haskpy.typeclasses.html">haskpy.typeclasses</a></li>
<li class="toctree-l2"><a class="reference internal" href="haskpy.utils.html">haskpy.utils</a></li>
<li class="toctree-l2"><a class="reference internal" href="haskpy.optics.html">haskpy.optics</a></li>
<li class="toctree-l2"><a class="reference internal" href="haskpy.testing.html">haskpy.testing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Changelog</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="../api.html">API</a><ul>
  <li><a href="haskpy.types.html">haskpy.types</a><ul>
  <li><a href="haskpy.types.maybe.html">haskpy.types.maybe</a><ul>
      <li>Previous: <a href="haskpy.types.maybe.html" title="previous chapter">haskpy.types.maybe</a></li>
      <li>Next: <a href="haskpy.types.maybe.Nothing.html" title="next chapter">haskpy.types.maybe.Nothing</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019-2020, Jaakko Luttinen.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 6.1.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../_sources/_autosummary/haskpy.types.maybe.Maybe.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>